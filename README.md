## Project 4: 内存管理 (Memory Management)

### 1. 项目概述 (Overall Goal)

本项目旨在为我们的操作系统引入核心的**虚拟内存（Virtual Memory）**机制。在此之前，所有进程都运行在同一个物理地址空间中，这带来了严重的安全隐患和管理难题。通过实现虚拟内存，我们将为每个进程提供一个独立的、受保护的、从零开始的虚拟地址空间，实现以下核心目标：

- **内存隔离**: 防止进程间非法访问内存，保障系统稳定性和安全性。
- **动态加载**: 允许用户程序被加载到物理内存的任意位置，而无需在编译时硬编码地址。
- **高级内存功能**: 为后续实现按需调页、页面换出、写时复制等高级功能奠定基础。

我们将采用 RISC-V 的 **Sv39** 分页模式，它使用**三级页表**将 39 位的虚拟地址转换为 56 位的物理地址。

---

### 2. 任务分解 (Task Breakdown)

#### Task 1: 启用虚拟内存并加载用户程序 (S-Core)

**核心目标**: 搭建虚拟内存的基础框架，让内核和用户程序都能在虚拟地址下正确运行。

*   **步骤 1: 理解 Sv39 虚拟内存机制**
    *   **地址格式**: 学习 Sv39 模式下的 39 位虚拟地址（VA）和 56 位物理地址（PA）的结构。
        *   VA: `VPN[2]` (9 bits) | `VPN[1]` (9 bits) | `VPN[0]` (9 bits) | `Page Offset` (12 bits)
        *   PA: `PPN[2]` (26 bits) | `PPN[1]` (9 bits) | `PPN[0]` (9 bits) | `Page Offset` (12 bits)
    *   **页表项 (PTE)**: 理解 64 位 PTE 的格式，特别是 `V, R, W, X, U` 等关键标志位的作用。
    *   **地址翻译过程**: 掌握 CPU 如何利用 `satp` 寄存器指向的页表基地址，通过三级页表（L2, L1, L0）将虚拟页号（VPN）翻译成物理页号（PPN）。
    *   **TLB**: 理解快表（TLB）作为地址翻译缓存的角色，以及 `sfence.vma` 指令的用途。

*   **步骤 2: 实现内核态的虚拟内存映射**
    *   **创建内核页表**: 在 `boot_kernel_map` 中为内核创建一个初始的**恒等映射（Identity Mapping）**或**线性映射（Linear Mapping）**。这意味着内核的虚拟地址和物理地址有固定的偏移关系（例如 `vaddr = paddr + offset`）。
    *   **映射关键区域**: 必须将内核代码段、数据段、栈、以及所有硬件设备（如 UART、PLIC）的物理地址映射到内核的虚拟地址空间中。
    *   **启用分页**: 在完成页表建立后，通过 `set_satp` 函数将页表基地址写入 `satp` 寄存器，并设置模式为 `SATP_MODE_SV39`，正式开启虚拟内存。
    *   **验证**: 确保开启分页后，内核依然能够通过虚拟地址正常运行（例如，`printk` 能够正常打印）。

*   **步骤 3: 为用户进程创建独立的地址空间**
    *   **修改加载器 (`load_task_img`)**:
        *   为每个新进程分配一个根页目录（L2 Page Table）。
        *   在加载 ELF 文件时，不再直接写入物理地址，而是为程序的 `.text`, `.data` 等段分配物理页框。
        *   在用户进程的页表中，建立从用户虚拟地址（如 `0x10000`）到新分配的物理页框的映射。
        *   为用户进程分配栈空间，并在其页表中建立对应的虚实映射。
    *   **修改上下文切换**: 在 `switch_to` 中，切换 `satp` 寄存器指向新进程的页表基地址，并刷新 TLB (`sfence.vma`)，以完成地址空间的切换。

---

#### Task 2: 实现按需调页 (On-demand Paging) (A-Core)

**核心目标**: 优化内存使用，只有在进程实际访问一个页面时才为其分配物理内存。

*   **步骤 1: 实现缺页异常处理 (Page Fault Handler)**
    *   在 `trap_handler` 中，识别由 `scause` 寄存器指示的 `Store page fault`, `Load page fault`, `Instruction page fault` 异常。
    *   从 `stval` 寄存器中获取导致缺页的虚拟地址。
    *   编写 `do_page_fault` 函数，负责处理缺页逻辑。

*   **步骤 2: 实现按需分配**
    *   修改 `do_exec`，在加载用户程序时，只建立页表结构，但**不立即分配物理页框**。PTE 的 `V` (Valid) 位保持为 0。
    *   在 `do_page_fault` 中，当检测到缺页是由于访问一个合法的、但尚未分配物理内存的区域时（例如，通过检查进程的虚拟内存区域 VMA 来判断），执行以下操作：
        1.  分配一个新的物理页框。
        2.  更新导致缺页的地址所对应的 PTE，填入新页框的 PPN，并设置 `V, R, W, X, U` 等正确的权限位。
        3.  刷新 TLB。
        4.  从异常处理中返回，让指令重新执行。

---

#### Task 3: 实现页面换出与换入 (Page Swap) (A-Core)

**核心目标**: 当物理内存耗尽时，能将不常用的页面临时存放到磁盘（SD卡）上，从而支持运行比物理内存更大的程序。

*   **步骤 1: 设计磁盘交换区 (Swap Area)**
    *   在 SD 卡上预留一块连续的空间作为交换区。
    *   实现一个简单的分配器来管理交换区中的空闲槽位。

*   **步骤 2: 实现页面换出 (Page Out)**
    *   当 `alloc_page` 发现物理内存不足时，触发页面替换算法（如 FIFO 或 Clock）。
    *   **选择牺牲页**: 找到一个要被换出的物理页框。
    *   **写回磁盘**: 将该页框的内容写入到 SD 卡交换区的一个空闲槽位。
    *   **更新页表**: 找到所有映射到这个物理页框的 PTE，将它们标记为**无效**（`V=0`），并在 PTE 的软件保留位中记录它在交换区的位置。
    *   **刷新 TLB**: 确保对该页面的后续访问会触发缺页异常。

*   **步骤 3: 实现页面换入 (Page In)**
    *   修改 `do_page_fault`。当缺页发生时，检查 PTE 的软件保留位。
    *   如果 PTE 表明该页已被换出到磁盘，则：
        1.  分配一个新的物理页框。
        2.  从 SD 卡的交换区将页面内容读回这个新页框。
        3.  更新 PTE，指向新的物理页框，并设置 `V=1`。
        4.  释放交换区中的槽位。

---

#### Task 4: 查看可用内存 (C-Core)

**核心目标**: 实现一个系统调用，让用户程序可以查询当前系统的剩余物理内存。

*   **步骤 1: 实现 `sys_get_mem`**
    *   在内核中维护一个全局变量，记录当前空闲物理页框的数量。
    *   实现一个新的系统调用，读取这个变量并乘以页大小，返回给用户。

---

#### Task 5: 内存页管道 (Memory Page Pipe) (C-Core)

**核心目标**: 实现一种高效的进程间通信机制，通过直接传递页面的所有权（重映射页表）来避免数据拷贝。

*   **步骤 1: 设计页管道 API**
    *   实现 `pipe_read(char *buf, int len)` 和 `pipe_write(char *buf, int len)` 系统调用。

*   **步骤 2: 实现零拷贝传递**
    *   **写操作**: 当进程 A 调用 `pipe_write` 时，内核找到 `buf` 所在的物理页框。
    *   **读操作**: 当进程 B 调用 `pipe_read` 时，内核不分配新内存，而是直接将进程 B 页表中 `buf` 对应的虚拟地址，映射到进程 A 之前写入的那个物理页框上。
    *   **所有权转移**: 为了安全，可以将进程 A 对该页面的映射解除或设置为只读，实现页面的所有权从 A 转移到 B。